#user  nobody;
worker_processes  1;

#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

#pid        logs/nginx.pid;


events {
    worker_connections  1024;
}


http {
    passenger_root /usr/lib/ruby/gems/1.8/gems/passenger-2.2.2;
    passenger_ruby /usr/bin/ruby1.8;

    include       mime.types;
    default_type  application/octet-stream;

    #log_format  main  '$remote_addr - $remote_user [$time_local] $request '
    #                  '"$status" $body_bytes_sent "$http_referer" '
    #                  '"$http_user_agent" "$http_x_forwarded_for"';

    #access_log  logs/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  0;
    keepalive_timeout  65;

    #gzip  on;

   server {
      listen 80;
      server_name _;
      root /mnt/app/current/public;

      # server-specific passenger settings
      passenger_enabled on;
      passenger_use_global_queue on;
      rails_env <%= rails_env %>;
      # We leave passenger_max_pool_size at the default for now. (It might
      # eventually be an ERB variable that can be set automatically based on the
      # instance type and what roles it's in.)
      # passenger_max_pool_size 6;

      # Set the max size for file uploads to 50Mb
      client_max_body_size 50M;
      
      error_page   400 /400.html;
      error_page   500 502 503 504  /500.html;
      location = /500.html {
        root /mnt/app/current/public;
      }
            
      #hide hidden files and folders
      location ~ /\..+ {
        deny  all;
      }

      #do not show the nginx version number in the server header
      server_tokens off;
    
      # this allows people to use images and css in their maintenance.html file
      if ($request_filename ~* \.(css|jpg|gif|png)$) {
  	    break;
      }
		
      # this rewrites all the requests to the maintenance.html
      # page if it exists in the doc root. This is for capistrano's
      # disable web task
      if (-f $document_root/system/maintenance.html) {
        rewrite  ^(.*)$  /system/maintenance.html last;
        break;
      }
      
      # see http://wiki.codemongers.com/NginxHttpStubStatusModule 
      # for more information
      location /nginx_status {
          # copied from http://blog.kovyrin.net/2006/04/29/monitoring-nginx-with-rrdtool/
          stub_status on;
          access_log   off;
          #only allow from localhost
          allow 127.0.0.1; 
          deny all;
      }

      location / {
        index  index.html index.htm;

        # location ~ ^/(images|javascripts|stylesheets)/ {
        #   expires 10y;
        # }

        if (-f $request_filename) { 
          break; 
        }

        # this is the meat of the rails page caching config
        # it adds .html to the end of the url and then checks
        # the filesystem for that file. If it exists, then we
        # rewite the url to have explicit .html on the end 
        # and then send it on its way to the next config rule.
        # if there is no file on the fs then it sets all the 
        # necessary headers and proxies to our upstream mongrels
        if (-f $request_filename.html) {
          rewrite (.*) $1.html break;
        }
      }

      include /etc/nginx/custom.conf;      
   }

    #
    #server {
    #    listen       8000;
    #    listen       somename:8080;
    #    server_name  somename  alias  another.alias;

    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}


    # HTTPS server
    #
    #server {
    #    listen       443;
    #    server_name  localhost;

    #    ssl                  on;
    #    ssl_certificate      cert.pem;
    #    ssl_certificate_key  cert.key;

    #    ssl_session_timeout  5m;

    #    ssl_protocols  SSLv2 SSLv3 TLSv1;
    #    ssl_ciphers  ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP;
    #    ssl_prefer_server_ciphers   on;

    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}

}
